[{"title":"二分法总结","date":"2018-11-22T07:43:49.000Z","path":"2018/11/22/二分法总结/","text":"二分法总结 二分查找有序数组a(a[0], … a[N-1]), 查找目标值target，维护一个target所在区间[l, r), 每次与中间元素a[m]比较(m=floor((l + r) / 2))，确定target所在区间，且区间长度缩减一半，依次进行，最终在长度为N的数组a中查找target值总共需要O(logN)时间复杂度，空间复杂度为O(1). C++ STL APIs Usage12345678910111213141516171819202122// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vector// lower_bound 第一个i, a[i] &gt;= t// upper_bound 第一个i, a[i] &gt; t// [lower_bound, upper_bound) int main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); up=std::upper_bound (v.begin(), v.end(), 20); std::cout &lt;&lt; \"lower_bound at position \" &lt;&lt; (low- v.begin()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper_bound at position \" &lt;&lt; (up - v.begin()) &lt;&lt; '\\n'; return 0;&#125; C++ STL APIs python implementationsref: [https://www.zhihu.com/question/3613238] C++ STL lower_bound() python implementation: 1234567891011# ie. find the smallest i such that a[i] &gt;= valuedef lower_bound(array, first, last, value): while (first &lt; last): # mid = first + ((last - first) &gt;&gt; 1) 注意&gt;&gt;优先级最低，需要加括号 # 不用(first + last) // 2 防止溢出 mid = first + (last - first) // 2 if (array[mid] &lt; value): first = mid + 1 else: last = mid return first C++ STL upper_bound() python implementation: 12345678910# ie. find the smallest i such that a[i] &gt; valuedef upper_bound(array, first, last, value): while (first &lt; last): mid = first + (last - first) // 2 # 此处看做条件c if (array[mid] &lt;= value): first = mid + 1 else: last = mid return first C++ STL APIs C++ implementations12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) // 只有此处不同 l = m + 1; else r = m; &#125; return l;&#125;// [l,r] 区间写法// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; //注意right初始化为n-1 int left(0), right(n-1), mid; while(left &lt;= right) // 注意结束判别条件，l&lt;=r 而不是 l&lt;r &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; // 注意 -1 &#125; &#125; return left; // left和right不一致，注意要返回left&#125;// return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right) &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 总结： 无论是lower_bound()还是upper_bound(), 都是返回不满足条件c的最小下标； return first or last是等价的; 区间表示法为[first, last)。 二分答案如果一个问题的解是离散的，且范围已知（ie 可以枚举），且判断一个解是否可行的代价较低，且答案具有单调性(ie 如果x是解，则x+i也是解， 如果x不是解，则x-i也不是解（或者反过来）。即满足条件和不满足条件的交界面只有一个，类似于判断条件C，array[i]&lt;value的条件在有序数组内即满足单调性)，则可以采用二分答案的做法来求解。 例题s二分搜索题目列表Ref: [https://blog.csdn.net/linhuanmars/article/details/31354941] Leetcode 35. Search Insert Position123456789101112131415161718192021222324252627282930313233343536373839404142434445// method 1int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; const int n = nums.size(); int l=0, r=n-1; while(l&lt;=r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] == target) return mid; if (nums[mid] &lt; target) l = mid+1; else r = mid-1; &#125; return l;&#125;// method 2 lower_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt; target) l = m + 1; else r = m; &#125; return l;&#125;// method 3 upper_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); // the 1st to not obby nums[i] &lt; target, ie nums[i] &gt; target while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt;= target) l = m + 1; else r = m; &#125; // 如果找到了则返回下标l-1, 没找到的话插入位置则是l if (l &amp;&amp; nums[l-1] == target) l--; return l;&#125; Leetcode ?. Search for a Range123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) l = m + 1; else r = m; &#125; return l;&#125;// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; printf (\"l=%d, r=%d\",left, right); return left;&#125; // return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; return left;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a[100],N,T; scanf(\"%d%d\", &amp;N, &amp;T); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; sort(a,a+N); // int lb = lower_bound(a, N, T); // int ub = upper_bound(a, N, T); int lb = LowerBound(a, N, T); int ub = UpperBound(a, N, T); printf(\"%d-%d\\n\", lb, ub); return 0;&#125; Leetcode 69. Sqrt(x)123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // 如果采用[l,r)写法，则r可能会溢出有符号整数的范围 // 采用[l,r]写法 // 找到第一个满足m&gt;x/m的m，ie m**2&gt;x的值， // 则m-1就是平方&lt;=x的最大整数，即sqrt(x)的整数部分。 int mySqrt(int x) &#123; int l = 1, r = x; while(l&lt;=r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m - 1; &#125; return l-1; &#125; // [l,r)写法，采用了unsigned int防止溢出 int mySqrt(int x) &#123; unsigned int l = 1, r = x+1; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m; &#125; return l-1; &#125;&#125;; Notes: 注意m&lt;=x/m的写法，替代了m*m&lt;=x的写法，防止溢出。 Leetcode 74. Search a 2D Matrix首先找到第一个元素matrix[i][0]&lt;=target的行i，再在matrix[i]内二分查找target值。时间复杂度为O(logn+logn), ie O(logn). 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int l = 0, r = matrix.size(); // 一旦有空行，则返回false // [] if (r == 0) return false; // [[]] if(matrix[0].size() == 0) return false; // [l,r), 查找第一个首元素&gt;target的行 while (l &lt; r) &#123; int m = l + (r - l) / 2; if (matrix[m][0] &lt;= target) l = m + 1; else r = m; &#125; // select 即为最后一个 &lt;= target的行 int select = l - 1; // 第一行的首元素都＞target，肯定不存在 if (select &lt; 0) &#123; return false; &#125; // [l,r] l = 0, r = matrix[select].size()-1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (matrix[select][m] &lt; target) l = m + 1; else if (matrix[select][m] &gt; target) r = m - 1; else return true; &#125; return false; &#125;&#125;; Leetcode 33. Search in Rotated Sorted Array因为没有重复元素，所以原始数组一定严格单调递增。可以根据a[m]与a[r]的大小关系，判断单调部分是[l,m]还是[m,r]（两者必然存在一个单调，因为断点只有一个，根据鸽巢定理)，再根据情况进行二分即可。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size()-1; // [l,r] while (l&lt;=r) &#123; int m = (l + r) / 2; // 直接找到 if (nums[m] == target) return m; // [m,r]一定单调 if (nums[m] &lt; nums[r]) &#123; // 判断是否在右侧 if (nums[m] &lt; target &amp;&amp; nums[r] &gt;= target) l = m+1; else r = m-1; &#125; // nums[m] &gt; nums[r], 断点在右侧，左侧[l,m]一定单调 else &#123; // 判断target是否在左侧 if (nums[l] &lt;= target &amp;&amp; nums[m] &gt; target) r = m-1; else // 否则在右侧 l = m+1; &#125; &#125; return -1; &#125;&#125;; Leetcode 81. Search in Rotated Sorted Array II有重复元素，可能只是非递减序列，无法再根据a[m]和a[r]的大小关系判断非递减部分，eg [2 2 2 2 2 3] rotate to [2 3 | 2 2 2 2] (a[m]=2=a[r],断点在左侧，右侧非递减) 或者 rotate to [2 2 2 2 3 | 2] (a[m]=2=a[r], 断点在右侧，左侧非递减)，但是当a[m]&lt;a[r]时，还是可以判断出来断点一定在左边的，因为在右边的话，只能有a[m]&gt;=a[r]，同理当a[m]&gt;a[r]时，单调区间为[l,m].如果a[m]与a[r]相等，则r–，因为无法判断，且a[r]!=target(a[m]!=target已经判断过了)肯定不是答案，缩减问题规模1个单位，最坏时间复杂度为O(n). 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (nums[m] == target) return true; if (nums[m] &lt; nums[r]) &#123; if (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + 1; else r = m - 1; &#125; else if (nums[m] &gt; nums[r]) &#123; if (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - 1; else l = m + 1; &#125; else &#123; r--; &#125; &#125; return false; &#125; 洛谷 P1024 一元三次方程求解已知根与根之间距离&gt;=1，因此只要用长度为1的区间去二分求解即可，注意区间端点重叠可能会重复答案，因此在挪动区间时需要加一个小eps防止答案在端点处被求解两次。也可以根据答案求解情况挪动区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;double eps = 1e-4;double interval_width = 1;double A,B,C,D;double f(double x)&#123; return A*x*x*x+B*x*x+C*x+D;&#125;double get_ans(double l, double r)&#123; // printf(\"(l=%lf, r=%lf)\", l,r); if (f(l) * f(r) &gt; 0) return 9999; while(r-l&gt;eps) &#123; double m = (l+r) / 2; if (f(m) * f(l) &lt;=0) r = m; else l = m; &#125; return (l+r)/2;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); vector&lt;double&gt; ans; double l = -100; scanf(\"%lf%lf%lf%lf\", &amp;A, &amp;B, &amp;C, &amp;D); while(l&lt;100) &#123; double solu = get_ans(l, l+interval_width); if (solu &lt; 101) &#123; ans.push_back(solu); // printf(\"%.2lf\", solu); &#125; l+=interval_width+eps; &#125; sort(ans.begin(), ans.end()); for (int i=0;i&lt;ans.size();i++) printf(\"%.2f \", ans[i]); return 0;&#125; 二分答案POJ 3258 跳石头 River Hopscotch最短跳跃距离最大–最小值最大问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int L, m, n;int a[50010];// 判断最短距离不少于x是否可以达到int check(int x)&#123; int last = 0; int moves = 0; for (int i=0;i&lt;=n;i++) &#123; if (a[i+1] - last &lt; x) // 太近了，需要搬石头 &#123; moves++; &#125; else &#123; last = a[i+1]; &#125; &#125; if (moves &gt; m) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d%d\", &amp;L, &amp;n, &amp;m); a[0] = 0; for (int i=1; i&lt;=n; i++) scanf(\"%d\", &amp;a[i]); a[n+1] = L; sort(a, a+n+2); int l = 0, r = L + 1; // 第一个不满足check(m)的m值，即第一个不能达到最短距离&gt;=m的m，即第一个无法使所有最短距离都&gt;=m的m,则m-1就是最大的最小值 while (l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); // printf (\"%d,%d,%d\\n\", l, r, m); // 最短距离&gt;=m可以达到 if (check(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf (\"%d\", l - 1); return 0;&#125; 洛谷 P1182 数列分段42451 [42][45][1]每段和最大值最小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, M;int a[100010]; // 判断每段和都&lt;=x, 即最大值&lt;=x是否可行int judge(int x)&#123; int i=0; int cur_sum = 0; int part_cnt = 0; while(i&lt;N) &#123; if (a[i] &gt; x) return 0; cur_sum += a[i++]; if (cur_sum &gt; x) &#123; i--; cur_sum = 0; part_cnt++; &#125; &#125; if (cur_sum) part_cnt++; if (part_cnt &gt; M) return 0; return 1;&#125;int main()&#123; // freopen(\"input.txt\",\"r\",stdin); scanf(\"%d%d\", &amp;N, &amp;M); int l = -1, r = 0; for (int i=0;i&lt;N;i++) &#123; scanf(\"%d\", &amp;a[i]); r += a[i]; l = max(l, a[i]); &#125; r++; // 满足judge(m)的最小的m while(l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; r = m; &#125; else &#123; l = m+1; &#125; &#125; printf (\"%d\", l); return 0;&#125; 洛谷 P1577 切绳子1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, K;int a[10010];int judge(int m)&#123; int cnt = 0; for (int i=0; i&lt;N; i++) &#123; cnt += a[i] / m; &#125; if (cnt &gt;= K) return 1; return 0;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); int l=0, r=-1; double inp; scanf(\"%d%d\",&amp;N,&amp;K); for (int i=0;i&lt;N;i++) &#123; scanf(\"%lf\",&amp;inp); a[i] = int(inp * 100000); r = max(r, a[i]); &#125; while(l&lt;r) &#123; double m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf(\"%.2lf\", (l-1)/100000.0); return 0;&#125;","tags":[]},{"title":"Hello World","date":"2018-09-15T14:48:12.139Z","path":"2018/09/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]