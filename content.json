[{"title":"动态规划专题","date":"2018-11-26T09:14:15.000Z","path":"2018/11/26/动态规划专题/","text":"动态规划(Dynamic Programming, DP)。 DP总结动态规划分类 基础 简单递推 LCS (最长公共子序列/串) LIS (最长上升子序列/串) 背包问题 (0-1\\多重\\完全\\分组) 区间DP 树形DP 数位DP 期望DP 状压DP(插头DP等) 特性 最优子结构 问题的最优解包含子问题的最优解 重叠子问题 f(x) 被重复调用计算 记忆化搜索 无后效性 例题s简单递推HDU 2084. 数塔状态定义：$dp[i][j]$: 从(0,0)走到(i,j)的最大路径和 状态转移方程：$dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + num[i][j] \\quad(j &gt;= 1)$$dp[i][j] = dp[i - 1][j] + num[i][j] \\quad(j == 0)$12345678910111213141516171819202122232425262728293031323334// HDU 2084#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int T, N;int a[101][101];int dp[101][101];int main()&#123; // freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; dp[0][0] = a[0][0]; for (int l = 1; l &lt; N; ++l) &#123; dp[l][0] = dp[l - 1][0] + a[l][0]; for (int e = 1; e &lt; l + 1; ++e) &#123; dp[l][e] = max(dp[l - 1][e], dp[l - 1][e - 1]) + a[l][e]; &#125; &#125; int ans = dp[N - 1][0]; for (int i = 1; i &lt; N; ++ i) &#123; ans = max(ans, dp[N - 1][i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; HDU 2018 母牛的故事斐波那契数列 1234567891011121314151617181920212223242526272829303132// HDU 2018 母牛的故事#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 55;ll f[MAXN] = &#123;1, 2, 3&#125;;// &#123;1, 2, 3, 4, 6&#125;// f[n] = f[n-1] + f[n-3]int main() &#123; int n; // freopen(\"input.txt\", \"r\", stdin); for (int i = 3; i &lt; MAXN; ++i) &#123; f[i] = f[i - 1] + f[i - 3]; &#125; while (1) &#123; cin &gt;&gt; n; if (!n) break; cout &lt;&lt; f[n - 1] &lt;&lt; endl; &#125; return 0;&#125; HDU 2044 一只小蜜蜂 根据对称性，发现从a到b等价于从1到b-a+1. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 55;ll dp[MAXN] = &#123;0, 1&#125;;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int T, a, b; cin &gt;&gt; T; for (int i = 2; i &lt; MAXN; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; while (T--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp[b - a + 1] &lt;&lt; endl; &#125; return 0;&#125; HDU 2041 超级楼梯123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 55;ll dp[MAXN] = &#123;1, 1&#125;;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T, a, b; cin &gt;&gt; T; for (int i = 2; i &lt; MAXN; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; while (T--) &#123; cin &gt;&gt; a; cout &lt;&lt; dp[a - 1] &lt;&lt; endl; &#125; return 0;&#125; HDU 2050 折线分割平面 退化考虑两条平行直线分割的情况，退化考虑直线分割的情况。 直线分割平面： N条🍌直线最多可以把平面分割成多少块？ 考虑添加第N条直线时，为了最多分割，必须要与前N-1条直线都🍌，且没有任何三条直线交于一点，第N条直线有N-1个交点，因为每增加N个交点，就增加N+1个平面(考虑交点之间的线段，将所在的原来的平面分为了2份，N个交点有N+1段)，因此第N条直线增加N个平面，第一条直线有划分2个平面，因此N条直线最多分割平面 $$2+2+3+4+5+…+N=1+\\frac{N*(N+1)}{2}$$. 考虑每次增加2条平行直线， 类似于直线分割平面，考虑第N次添加时，前面已经有$2*(N-1)$条直线了，所以第N次添加的两条直线，即第$2N-1$和第$2N$条直线，各能增加$2*N-1$个平面。因此第N次添加增加的块数是$2*(2*N-1)=4*N-2$，因此最多分割平面数为 $$1+\\frac{4N*(N+1)}{2}-2N=2N^2+1$$. 再来看这道题，如果将每次加入的平行边的一头🍌，1,3面合为一个面，则会少一个面，每次添加折线都会比添加平行线少一个面，因此N条直线后会少N个面，因此N条折线最多分割平面数为$$2N^2-N+1$$. 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T, n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cout &lt;&lt; 2 * n * n + 1 - n &lt;&lt; endl; &#125; return 0;&#125; CF 429B Working Out给出一个矩阵，一个人从左上角走到右下角，一个人从左下角走到右上角， 两个人的轨迹只会在一个点相交， 问两个人经过路径上的数的和最大的情况下最大和是多少(交点的数不算)。 枚举交点(i,j) dp1[i][j]: 从(1,1)到(i,j)的最大分数，注意只能从(i,j)的左面或者上面来 dp2[i][j]: 从(i,j)到(n,m)的最大分数，注意去向是向右或者向下 dp3[i][j]: 从(n,1)到(i,j)的最大分数，注意只能从(i,j)的左面或者下面来 dp4[i][j]: 从(i,j)到(1,m)的最大分数, 注意去向是向右或者向上 注意交点一定不可能在边界处取得，比如都在左边界(x,1)🍌的话，则不能都往右走，肯定要有一个向上或者向下，而对方一定就是从那来的，因此交点肯定不止一个。这题一开始理解错了，对两者速度不同，如果理解成可以不止一个交点，但两者同时都在的交点只有一个的话，则同样的路径，无法保证同时都在的交点数有多少个（即使两者路径完全重合，也可以是一个跑🏃，一个追，永远没有相遇的时候），这样任何方案都无法保证满足只相遇在一个健身房的条件，题目没有意义，只能理解成两者路径轨迹只有一个交点的意思。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 1e3+5;int dp1[MAXN][MAXN], dp2[MAXN][MAXN], dp3[MAXN][MAXN], dp4[MAXN][MAXN], a[MAXN][MAXN];int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m; while(~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; memset(dp1, 0, sizeof(dp1)); memset(dp2, 0, sizeof(dp2)); memset(dp3, 0, sizeof(dp3)); memset(dp4, 0, sizeof(dp4)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;a[i][j]); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; dp1[i][j] = max(dp1[i-1][j], dp1[i][j-1]) + a[i][j]; &#125; for (int i = n; i &gt;= 1; --i) for (int j = m; j &gt;= 1; --j) &#123; dp2[i][j] = max(dp2[i+1][j], dp2[i][j+1]) + a[i][j]; &#125; for (int i = n; i &gt;= 1; --i) for (int j = 1; j &lt;= m; ++j) &#123; dp3[i][j] = max(dp3[i+1][j], dp3[i][j-1]) + a[i][j]; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) &#123; dp4[i][j] = max(dp4[i-1][j], dp4[i][j+1]) + a[i][j]; &#125; int ans = 0; for (int i = 2; i &lt; n; ++i) for (int j = 2; j &lt; m; ++j) &#123; // 上-&gt;下 左-&gt;右 ans = max(ans, dp1[i-1][j] + dp2[i+1][j] + dp3[i][j-1] + dp4[i][j+1]); // 左-&gt;右 下-&gt;上 ans = max(ans, dp1[i][j-1] + dp2[i][j+1] + dp3[i+1][j] + dp4[i-1][j]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; ZOJ 3747 Attack On Titans给n个士兵排队，每个士兵三种G、R、P可选，求至少有m个连续G士兵，最多有k个连续R士兵的排列的种数。 至少转成至多比较简单至少K个 &lt;==&gt; 至多无穷个 - 至多K-1个 枚举考虑第i个是G\\R\\P的三种情况，考虑至多，减去不符合条件的情况数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 1e6+100;const int MOD = 1000000007;// G R P// G 至少M个连续 // R 至多K个连续// 都转化为至多连续问题， 至多N - 至多M-1ll dp[MAXN][3];ll N, M, K;// 计算至多u个G，至多v个R的方案数int calc(int u, int v) &#123; // memset(dp, 0, sizeof(dp)); dp[0][2] = 1; for (int i = 1; i &lt;= N; ++i) &#123; ll sum = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD ; dp[i][2] = sum; if (i &lt;= u) dp[i][0] = sum; else dp[i][0] = (sum - dp[i - u - 1][1] - dp[i - u - 1][2]) % MOD; //合并了当i==u+1情况 if (i &lt;= v) dp[i][1] = sum; else dp[i][1] = (sum - dp[i - v - 1][0] - dp[i - v - 1][2]) % MOD; &#125; return (dp[N][0] + dp[N][1] + dp[N][2]) % MOD;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N &gt;&gt; M &gt;&gt; K) &#123; cout &lt;&lt; ((calc(N, K) - calc(M - 1, K)) % MOD + MOD) % MOD &lt;&lt; endl; &#125; return 0;&#125; UVA 10328 Coin Tossn张牌，求至少连续K张正面朝上的方案数。 类似上题，注意k-1可能是0，则初始化可能会改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 1e2 + 10;// 0 正面// 1 反面int dp[MAXN][2];int K, N;int calc(int u) &#123; // if (u == 0) return 1; memset(dp, 0, sizeof(dp)); dp[0][0] = u != 0; dp[0][1] = 1; for (int i = 1; i &lt; N; ++i) &#123; int sum = dp[i - 1][0] + dp[i - 1][1]; dp[i][1] = sum; if (i &lt; u) &#123; dp[i][0] = sum; &#125; else if (i == u) &#123; dp[i][0] = sum - 1; &#125; else &#123; dp[i][0] = sum - dp[i - u - 1][1]; &#125; &#125; return dp[N - 1][0] + dp[N - 1][1];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(cin &gt;&gt; N &gt;&gt; K) &#123; int b = 1; for (int i = 0; i &lt; N; ++i) b *= 2; // cout &lt;&lt; calc(N) &lt;&lt; endl; // cout &lt;&lt; calc(K - 1) &lt;&lt; endl; cout &lt;&lt; b - calc(K - 1) &lt;&lt; endl; &#125; return 0;&#125; HDU 4747 Mex给定非负整数序列{a_i}, 定义函数mex(L,R)为在[a_L, a_R]中未出现过的最小非负整数， 计算所有mex(L,R)的和(1&lt;=L&lt;=R&lt;=N). (1 &lt;= n &lt;= 200000, 0 &lt;= ai &lt;= 10^9) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 2e5+10;int a[MAXN];int pos[MAXN];int full[MAXN];int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int n; while((cin &gt;&gt; n) &amp;&amp; n) &#123; int i, j; for (i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; memset(pos, 0, sizeof(pos)); memset(full, 0, sizeof(full)); int last; ll tt = 0, ans = 0; for (i = 1; i &lt;= n; ++i) &#123; if (a[i] &lt; n) &#123; last = pos[a[i]]; pos[a[i]] = i; for (j = a[i]; j &lt; n; ++j) &#123; if (j) full[j] = min(full[j - 1], pos[j]); else full[j] = i; if (full[j] &gt; last) tt += full[j] - last; else // 后续一定都是else, full[j] &lt;= last break; &#125; &#125; ans += tt; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 两种思路： 线段树 等后续复习线段树专题再讨论。 递推计数 有点难理解，依次考虑所有以i结尾的区间的$mex(x, i)$的临时和$tt[i]$，其中$x &lt;= i$，最后累加所有$tt$到$ans$即为答案。 考虑如何从$tt[i - 1]$递推$tt[i]$, 当新元素$a[i]$出现时，$a[i]$的上一次出现位置如果是$j(i.e \\quad j &lt; i \\quad s.t \\quad a[j] == a[i])$，则$j$之前的x到i的$mex(x, i)$与之前的一样，因为a[i]之前就出现过了，出现几次没关系，不影响答案。有可能影响答案的区间是$[x, i] (j+1&lt;=x&lt;=i)$。 考虑如何才能影响答案，可能到某个k为止，$mex(x, i-1) = a[i] (j + 1 &lt;= x &lt;= k)$, 这说明从[x, i-1]中0~a[i]-1都出现过，而[k+1, i-1]就不满足该条件，则增加a[i]会导致$mex(x, i) (j + 1 &lt;= x &lt;= k)$至少从a[i]变成a[i]+1, 因此总的tt至少会增加k - j, k是满足[x, i-1]中0~a[i]-1都出现过的最大下标，结合考虑a[i]=a[i], 则k是满足[x, i]中0~a[i]都出现过的最大下标，即代码中的full数组。 注意前面的至少, 因为有可能a[i]+1在之前出现过, 因此类似地，我们需要不断考虑a[i]+1, a[i]+2, … N - 1, 因为一共N个数，根据鸽巢原理，mex()的值域只能在[0, N], 且当a[i]&gt;=N时，则值域一定为[0, N-1]。 Ref: [https://blog.csdn.net/qq1965610770/article/details/80041940] HDU 4489 The King’s Ups and Downs有n个高矮不同的人，求n个人排成一列使得高-矮-高或者矮-高-矮依次排列的种数。 组合DP，设高度分别为1, 2, … n. (1) 1 (2) 2 ... n-1 (n) (x) 是可插入的位置标号 考虑第n个人，假设前n-1个人已经按照要求排好了，则第n个人有n个位置可放，对于任一位置j，显然第n个人的身高n大于前n-1个人的任何人的身高，所以第n个人左边的j-1个人的排列，必须要满足最后一个人是通过身高下降得到的；右边的n-j个人中，最开始的那个人一定是通过身高升高得到后一个人的。前面的j-1个人有$n-1 \\choose j-1$种选择。设状态dp[i][0]表示前面有i个人, 且第一个人通过上升得到第二个人的总排列总数, dp[i][1]表示前面有i个人，且最后一个人是通过下降得到的。由对称性，dp[i][0] = dp[i][1] = sum[i] / 2, 其中sum[i]为i个人总的满足要求的排列数。对于n&gt;=2的情况，高低高和低高低的情况是一样多的，因为对于n为奇数时，任意高低高方案，首尾总有一个高低，将首尾元素的较低者放在对面位置即可构造一个低高低方案；同理，对于任意低高低方案，将首尾元素的较高者放在对面位置即可构造一个高低高方案，且是一一对应（单射+满射）。对于n是偶数，直接将n反转，即可得到一一对应的高低高或者低高低。因为高低高或者低高低覆盖了全部可能，所以各是sum[i] / 2。 n为奇数： 低高低 1 9 2 8 3 3 1 9 2 8 1 9 2 8 3 高低高 9 1 8 2 7 7 9 1 8 2 9 1 8 2 7 n为偶数： 1 3 2 4 4 2 3 1 所以第n个人放到位置j，有$ n-1 \\choose j-1 $ * dp[j-1][0] * dp[n-j][1]种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAXN = 22;ll dp[MAXN][2];ll sum[MAXN];// 求组合数ll C(int a, int b) &#123; if (b == 0) return 1; ll res = 1; for (int i = 0; i &lt; b; ++i) &#123; res *= (a - i); &#125; for (int i = 1; i &lt;= b; ++i) &#123; res /= i; &#125; return res;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int P, D, n; dp[0][0] = dp[0][1] = 1; dp[1][0] = dp[1][1] = 1; sum[1] = 1; for (int i = 2; i &lt;= 20; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; sum[i] += dp[j - 1][0] * dp[i - j][1] * C(i - 1, j - 1); &#125; dp[i][0] = dp[i][1] = sum[i] / 2; &#125; cin &gt;&gt; P; while (P--) &#123; cin &gt;&gt; D &gt;&gt; n; cout &lt;&lt; D &lt;&lt; \" \" &lt;&lt; sum[n] &lt;&lt; endl; &#125; return 0;&#125; HDU 4054 Number String给一个只含‘I&apos;,&apos;D&apos;,&apos;?&apos;三种字符的字符串，I表示当前数字大于前面的数字，D表示当前的数字小于前面一位的数字，?表示当前位既可以小于又可以大于。 问1~n的排列中有多少个满足该字符串。 TODO","tags":[]},{"title":"第K大的数 (二分答案, 笛卡尔乘积第K大)","date":"2018-11-23T11:22:53.000Z","path":"2018/11/23/第K大的数-二分答案-笛卡尔乘积第K大/","text":"数组A和数组B，里面都有n个整数。数组C共有n^2个整数，分别是A[0] B[0],A[0] B[1] … A[1] B[0], A[1] B[1] … A[n - 1] * B[n - 1]（数组A同数组B的组合）。求数组C中第K大的数。例如：A：1 2 3，B：2 3 4。A与B组合成的C包括2 3 4 4 6 8 6 9 12共9个数。 对A和B排序，再二分答案，利用单调性，可以在O(n)内求出有多少个数比当前答案大。 第K大的数，即有K-1个数比它大，定义函数judge(x)判断有多少个数比x大，第一个不满足judge(x)&gt;=K的x，即是第K大的数。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int maxn = 5e4;int n, K;LL a[maxn+10], b[maxn+10];int judge(LL x)&#123; int cnt = 0; for (int i = 0, j = n - 1; i &lt; n; i++) &#123; for (; j &gt;= 0 &amp;&amp; a[i] * b[j] &gt; x; j--); cnt += n - 1 - j; &#125; return cnt;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;K); for(int i = 0; i &lt; n; i++) scanf(\"%lld%lld\", &amp;a[i], &amp;b[i]); sort(a, a+n); sort(b, b+n); LL l = 0, r = 1e18; while (l &lt; r) &#123; LL m = l + (r - l) / 2; if (judge(m) &gt;= K) l = m + 1; else r = m; &#125; printf(\"%lld\", l); return 0;&#125; submit: [https://www.51nod.com/Challenge/Problem.html#!#problemId=1105]","tags":[]},{"title":"POJ 3111 K Best (二分答案, 平均值最大化)","date":"2018-11-23T11:06:25.000Z","path":"2018/11/23/POJ-3111-K-Best-二分答案-平均值最大化/","text":"POJ 3111 题意： n件珠宝，每件价值v_i, 重w_i, 希望保留K件，使得单位重量的价值最大。 直接按照价值重量密度贪心不可，因为各件珠宝的密度所占的比重不同（重量大的，密度也占的比重大），可以二分答案，判断是否存在某种划分，使得单位重量价值&gt;=x，即Σ(vi-wi*x)&gt;=0, 贪心选择前K大的即可判断。二分答案，浮点数二分，求得最大的x，满足单位重量&gt;=x。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, K;struct jewels&#123; int id; int v; int w; double comp_key;&#125;J[100010];bool cmp(const jewels &amp;l, const jewels &amp;r)&#123; return l.comp_key &gt; r.comp_key;&#125;int judge(double x)&#123; for (int i = 0; i &lt; N; i++) J[i].comp_key = J[i].v - J[i].w * x; double sum = 0; sort(J, J + N, cmp); for (int i = 0; i &lt; K; i++) sum += J[i].comp_key; return sum &gt;= 0;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d%d\", &amp;J[i].v, &amp;J[i].w); J[i].id = i+1; &#125; double l = 0, r = 1e8; // (r-l)/2^100的精度足够 可行范围[l,r) for (int i = 0; i &lt; 100; i++) &#123; double mid = (l + r) / 2; if (judge(mid)) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; // printf (\"%.2f\\n\", l); for (int i = 0; i &lt; K; i++) printf (\"%d%c\", J[i].id, i &lt; K - 1 ? ' ' : '\\n'); return 0;&#125;","tags":[]},{"title":"贪心法总结","date":"2018-11-23T08:33:55.000Z","path":"2018/11/23/贪心法总结/","text":"贪心法总结 基本思想在多阶段决策问题中，总是“短视”地做出当前环境下最好的决策（局部最优选择），希望最终整体结果也较优，某些特殊的问题经过证明可以得出贪心结果最终也可能是整体最优解。 一个贪心问题需要有以下要素： 贪心选择性质：这是与DP的不同，一系列局部最优的贪心选择，每做一次贪心选择，就将原问题简化为规模更小的子问题，继而再进行贪心选择。如果对于一个具体问题，可以证明每一步所做的贪心选择最终会导向问题的整体最优解，则问题具有贪心选择性质。 最优子结构性质：整个问题的最优解包含子问题的最优解，可以用反证法证明，DP算法也要求此性质。 经典问题活动时间安排问题 若干个区间[s_i,t_i], 选择尽可能多的不交叉重叠的区间，数量最多为多少贪心选择结束时间更早的活动，因为可以给后续活动留下更多空间，至少不会比最优解差。 submit: [http://www.51nod.com/Challenge/Problem.html#!#problemId=1428] 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N;struct act&#123; int begin, end;&#125;t[10010];bool cmp(act &amp;l, act &amp;r)&#123; return (l.end &lt; r.end) || (l.end == r.end &amp;&amp; l.begin &lt; r.begin);&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); for (int i=0;i&lt;N;i++) scanf(\"%d%d\", &amp;t[i].begin, &amp;t[i].end); sort(t, t+N, cmp); int last_time = -1, ans = 0; for (int i=0;i&lt;N;i++) &#123; if (t[i].begin &gt;= last_time) &#123; ans++; last_time = t[i].end; &#125; &#125; printf (\"%d\\n\", ans); return 0;&#125; 区间覆盖问题POJ 3069 直线上有N个点，{ Xi | i=1…N }，选择若干个加上标记，每个标记可以覆盖距离为R的区域，希望为尽可能少的点添加标记，问至少要标记多少个点？ 从最左边的点开始考虑，保证能覆盖它，且尽可能右移的点被标记，再找到第一个没被覆盖的点，用同样的贪心策略求解。 NYOJ 1170 最大的数 n个数，在n-1个间隔中间添加+号或者*号，可以任意添加括号，但不许改变相对顺序，使结果最大。 不难发现，如果没有1，乘法一定比加法大。如果有1，则应该选择将1加在左边还是加在右边，a 1 b, (a+1)b与a\\(1+b)相比，发现应该把1加在较小的一侧。但是当a==b时，如何选择？由 4 1 4 1 的最优方案是 (4+1)*(4+1)，应该优先加在左边。当a值比较小时，该规律并不适用，比如 2 1 1 2的最优方案时(2+1)*(1+2)=9，而不是(2 (1 + 1) 2)=8，因此特殊情况需要判断，即 2 1 1 时，应该把中间的1加在左边的2，而不是右边较小的1，且(2+1)+1=4=2*(1+1)，每次把1加上后，原来的1相当于消失，最后累乘所有元素即是最大的结果。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MOD 10086 using namespace std;int N, a[10005];int main()&#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d\", &amp;N)) &#123; a[0] = a[N+1] = 21; for (int i = 1; i &lt;= N; i++) scanf(\"%d\", &amp;a[i]); if (N &gt; 1) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (a[i] == 1) &#123; // 1 加在左边 if(a[i-1] &lt;= a[i+1] || (a[i-1] == 2 &amp;&amp; a[i+1] == 1)) &#123; a[i] += a[i-1]; a[i-1] = 1; &#125; // 1 加在右边 else &#123; a[i+1] += a[i]; i++; &#125; &#125; &#125; &#125; for (int i = 2; i &lt;= N; i++) a[1] = (a[1] * a[i]) % MOD; printf(\"%d\\n\", a[1]); &#125; return 0;&#125; 合并果子 现在有n堆果子，第i堆有ai个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 类似于哈夫曼编码，贪心合并最少的两堆果子，可以用优先队列或堆进行优化，时间复杂度为O(nlogn). 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 洛谷 P1090 https://www.luogu.org/problemnew/show/P1090#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;// #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAXN = 1e5;int fruits[MAXN + 10];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int T, N, tmp1, tmp2; // cin &gt;&gt; T; T = 1; while(T--) &#123; LL ans = 0; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; fruits[i]; Q.push(fruits[i]); &#125; sort(fruits, fruits + N); for (int i = 0; i &lt; N - 1; ++i) &#123; tmp1 = Q.top(); Q.pop(); tmp2 = Q.top(); Q.pop(); ans += (tmp1 + tmp2); Q.push(tmp1 + tmp2); &#125; // for (int i = 0; i &lt; N - 1; ++i) &#123; // LL tmp = (fruits[i + 1] += fruits[i]); // ans += tmp; // int j; // for (j = i + 2; j &lt; N &amp;&amp; fruits[j] &lt; tmp; ++j) &#123; // fruits[j - 1] = fruits[j]; // &#125; // fruits[j - 1] = tmp; // &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[]},{"title":"二分法总结","date":"2018-11-22T07:43:49.000Z","path":"2018/11/22/二分法总结/","text":"二分法总结 二分查找有序数组a(a[0], … a[N-1]), 查找目标值target，维护一个target所在区间[l, r), 每次与中间元素a[m]比较(m=floor((l + r) / 2))，确定target所在区间，且区间长度缩减一半，依次进行，最终在长度为N的数组a中查找target值总共需要O(logN)时间复杂度，空间复杂度为O(1). C++ STL APIs Usage12345678910111213141516171819202122// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vector// lower_bound 第一个i, a[i] &gt;= t// upper_bound 第一个i, a[i] &gt; t// [lower_bound, upper_bound) int main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); up=std::upper_bound (v.begin(), v.end(), 20); std::cout &lt;&lt; \"lower_bound at position \" &lt;&lt; (low- v.begin()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper_bound at position \" &lt;&lt; (up - v.begin()) &lt;&lt; '\\n'; return 0;&#125; C++ STL APIs python implementationsref: [https://www.zhihu.com/question/3613238] C++ STL lower_bound() python implementation: 1234567891011# ie. find the smallest i such that a[i] &gt;= valuedef lower_bound(array, first, last, value): while (first &lt; last): # mid = first + ((last - first) &gt;&gt; 1) 注意&gt;&gt;优先级最低，需要加括号 # 不用(first + last) // 2 防止溢出 mid = first + (last - first) // 2 if (array[mid] &lt; value): first = mid + 1 else: last = mid return first C++ STL upper_bound() python implementation: 12345678910# ie. find the smallest i such that a[i] &gt; valuedef upper_bound(array, first, last, value): while (first &lt; last): mid = first + (last - first) // 2 # 此处看做条件c if (array[mid] &lt;= value): first = mid + 1 else: last = mid return first C++ STL APIs C++ implementations12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) // 只有此处不同 l = m + 1; else r = m; &#125; return l;&#125;// [l,r] 区间写法// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; //注意right初始化为n-1 int left(0), right(n-1), mid; while(left &lt;= right) // 注意结束判别条件，l&lt;=r 而不是 l&lt;r &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; // 注意 -1 &#125; &#125; return left; // left和right不一致，注意要返回left&#125;// return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right) &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 总结： 无论是lower_bound()还是upper_bound(), 都是返回不满足条件c的最小下标； return first or last是等价的; 区间表示法为[first, last)。 二分答案如果一个问题的解是离散的，且范围已知（ie 可以枚举），且判断一个解是否可行的代价较低，且答案具有单调性(ie 如果x是解，则x+i也是解， 如果x不是解，则x-i也不是解（或者反过来）。即满足条件和不满足条件的交界面只有一个，类似于判断条件C，array[i]&lt;value的条件在有序数组内即满足单调性)，则可以采用二分答案的做法来求解。 例题s二分搜索题目列表Ref: [https://blog.csdn.net/linhuanmars/article/details/31354941] Leetcode 35. Search Insert Position123456789101112131415161718192021222324252627282930313233343536373839404142434445// method 1int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; const int n = nums.size(); int l=0, r=n-1; while(l&lt;=r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] == target) return mid; if (nums[mid] &lt; target) l = mid+1; else r = mid-1; &#125; return l;&#125;// method 2 lower_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt; target) l = m + 1; else r = m; &#125; return l;&#125;// method 3 upper_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); // the 1st to not obby nums[i] &lt; target, ie nums[i] &gt; target while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt;= target) l = m + 1; else r = m; &#125; // 如果找到了则返回下标l-1, 没找到的话插入位置则是l if (l &amp;&amp; nums[l-1] == target) l--; return l;&#125; Leetcode ?. Search for a Range123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) l = m + 1; else r = m; &#125; return l;&#125;// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; printf (\"l=%d, r=%d\",left, right); return left;&#125; // return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; return left;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a[100],N,T; scanf(\"%d%d\", &amp;N, &amp;T); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; sort(a,a+N); // int lb = lower_bound(a, N, T); // int ub = upper_bound(a, N, T); int lb = LowerBound(a, N, T); int ub = UpperBound(a, N, T); printf(\"%d-%d\\n\", lb, ub); return 0;&#125; Leetcode 69. Sqrt(x)123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // 如果采用[l,r)写法，则r可能会溢出有符号整数的范围 // 采用[l,r]写法 // 找到第一个满足m&gt;x/m的m，ie m**2&gt;x的值， // 则m-1就是平方&lt;=x的最大整数，即sqrt(x)的整数部分。 int mySqrt(int x) &#123; int l = 1, r = x; while(l&lt;=r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m - 1; &#125; return l-1; &#125; // [l,r)写法，采用了unsigned int防止溢出 int mySqrt(int x) &#123; unsigned int l = 1, r = x+1; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m; &#125; return l-1; &#125;&#125;; Notes: 注意m&lt;=x/m的写法，替代了m*m&lt;=x的写法，防止溢出。 Leetcode 74. Search a 2D Matrix首先找到第一个元素matrix[i][0]&lt;=target的行i，再在matrix[i]内二分查找target值。时间复杂度为O(logn+logn), ie O(logn). 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int l = 0, r = matrix.size(); // 一旦有空行，则返回false // [] if (r == 0) return false; // [[]] if(matrix[0].size() == 0) return false; // [l,r), 查找第一个首元素&gt;target的行 while (l &lt; r) &#123; int m = l + (r - l) / 2; if (matrix[m][0] &lt;= target) l = m + 1; else r = m; &#125; // select 即为最后一个 &lt;= target的行 int select = l - 1; // 第一行的首元素都＞target，肯定不存在 if (select &lt; 0) &#123; return false; &#125; // [l,r] l = 0, r = matrix[select].size()-1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (matrix[select][m] &lt; target) l = m + 1; else if (matrix[select][m] &gt; target) r = m - 1; else return true; &#125; return false; &#125;&#125;; Leetcode 33. Search in Rotated Sorted Array因为没有重复元素，所以原始数组一定严格单调递增。可以根据a[m]与a[r]的大小关系，判断单调部分是[l,m]还是[m,r]（两者必然存在一个单调，因为断点只有一个，根据鸽巢定理)，再根据情况进行二分即可。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size()-1; // [l,r] while (l&lt;=r) &#123; int m = (l + r) / 2; // 直接找到 if (nums[m] == target) return m; // [m,r]一定单调 if (nums[m] &lt; nums[r]) &#123; // 判断是否在右侧 if (nums[m] &lt; target &amp;&amp; nums[r] &gt;= target) l = m+1; else r = m-1; &#125; // nums[m] &gt; nums[r], 断点在右侧，左侧[l,m]一定单调 else &#123; // 判断target是否在左侧 if (nums[l] &lt;= target &amp;&amp; nums[m] &gt; target) r = m-1; else // 否则在右侧 l = m+1; &#125; &#125; return -1; &#125;&#125;; Leetcode 81. Search in Rotated Sorted Array II有重复元素，可能只是非递减序列，无法再根据a[m]和a[r]的大小关系判断非递减部分，eg [2 2 2 2 2 3] rotate to [2 3 | 2 2 2 2] (a[m]=2=a[r],断点在左侧，右侧非递减) 或者 rotate to [2 2 2 2 3 | 2] (a[m]=2=a[r], 断点在右侧，左侧非递减)，但是当a[m]&lt;a[r]时，还是可以判断出来断点一定在左边的，因为在右边的话，只能有a[m]&gt;=a[r]，同理当a[m]&gt;a[r]时，单调区间为[l,m].如果a[m]与a[r]相等，则r–，因为无法判断，且a[r]!=target(a[m]!=target已经判断过了)肯定不是答案，缩减问题规模1个单位，最坏时间复杂度为O(n). 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (nums[m] == target) return true; if (nums[m] &lt; nums[r]) &#123; if (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + 1; else r = m - 1; &#125; else if (nums[m] &gt; nums[r]) &#123; if (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - 1; else l = m + 1; &#125; else &#123; r--; &#125; &#125; return false; &#125; 洛谷 P1024 一元三次方程求解已知根与根之间距离&gt;=1，因此只要用长度为1的区间去二分求解即可，注意区间端点重叠可能会重复答案，因此在挪动区间时需要加一个小eps防止答案在端点处被求解两次。也可以根据答案求解情况挪动区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;double eps = 1e-4;double interval_width = 1;double A,B,C,D;double f(double x)&#123; return A*x*x*x+B*x*x+C*x+D;&#125;double get_ans(double l, double r)&#123; // printf(\"(l=%lf, r=%lf)\", l,r); if (f(l) * f(r) &gt; 0) return 9999; while(r-l&gt;eps) &#123; double m = (l+r) / 2; if (f(m) * f(l) &lt;=0) r = m; else l = m; &#125; return (l+r)/2;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); vector&lt;double&gt; ans; double l = -100; scanf(\"%lf%lf%lf%lf\", &amp;A, &amp;B, &amp;C, &amp;D); while(l&lt;100) &#123; double solu = get_ans(l, l+interval_width); if (solu &lt; 101) &#123; ans.push_back(solu); // printf(\"%.2lf\", solu); &#125; l+=interval_width+eps; &#125; sort(ans.begin(), ans.end()); for (int i=0;i&lt;ans.size();i++) printf(\"%.2f \", ans[i]); return 0;&#125; 二分答案POJ 3258 跳石头 River Hopscotch最短跳跃距离最大–最小值最大问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int L, m, n;int a[50010];// 判断最短距离不少于x是否可以达到int check(int x)&#123; int last = 0; int moves = 0; for (int i=0;i&lt;=n;i++) &#123; if (a[i+1] - last &lt; x) // 太近了，需要搬石头 &#123; moves++; &#125; else &#123; last = a[i+1]; &#125; &#125; if (moves &gt; m) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d%d\", &amp;L, &amp;n, &amp;m); a[0] = 0; for (int i=1; i&lt;=n; i++) scanf(\"%d\", &amp;a[i]); a[n+1] = L; sort(a, a+n+2); int l = 0, r = L + 1; // 第一个不满足check(m)的m值，即第一个不能达到最短距离&gt;=m的m，即第一个无法使所有最短距离都&gt;=m的m,则m-1就是最大的最小值 while (l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); // printf (\"%d,%d,%d\\n\", l, r, m); // 最短距离&gt;=m可以达到 if (check(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf (\"%d\", l - 1); return 0;&#125; 洛谷 P1182 数列分段42451 [42][45][1]每段和最大值最小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, M;int a[100010]; // 判断每段和都&lt;=x, 即最大值&lt;=x是否可行int judge(int x)&#123; int i=0; int cur_sum = 0; int part_cnt = 0; while(i&lt;N) &#123; if (a[i] &gt; x) return 0; cur_sum += a[i++]; if (cur_sum &gt; x) &#123; i--; cur_sum = 0; part_cnt++; &#125; &#125; if (cur_sum) part_cnt++; if (part_cnt &gt; M) return 0; return 1;&#125;int main()&#123; // freopen(\"input.txt\",\"r\",stdin); scanf(\"%d%d\", &amp;N, &amp;M); int l = -1, r = 0; for (int i=0;i&lt;N;i++) &#123; scanf(\"%d\", &amp;a[i]); r += a[i]; l = max(l, a[i]); &#125; r++; // 满足judge(m)的最小的m while(l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; r = m; &#125; else &#123; l = m+1; &#125; &#125; printf (\"%d\", l); return 0;&#125; 洛谷 P1577 切绳子1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, K;int a[10010];int judge(int m)&#123; int cnt = 0; for (int i=0; i&lt;N; i++) &#123; cnt += a[i] / m; &#125; if (cnt &gt;= K) return 1; return 0;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); int l=0, r=-1; double inp; scanf(\"%d%d\",&amp;N,&amp;K); for (int i=0;i&lt;N;i++) &#123; scanf(\"%lf\",&amp;inp); a[i] = int(inp * 100000); r = max(r, a[i]); &#125; while(l&lt;r) &#123; double m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf(\"%.2lf\", (l-1)/100000.0); return 0;&#125; CodeForces 660C. Hard Process 给定n个01元素的数组，每次操作可以将一个0变为1，求最多经过K次操作最长的连续的1的个数。 最简单的方法0O(n^2)枚举区间的左右端点[l, r], 如果其中0的个数&lt;=K, 则可以经过不超过K次将其全变为1，ans = max(ans, r - l + 1).判断0的个数，可以用前缀和O(1)时间完成。方法1O(nlogn)只枚举左端点l，右端点r即满足Zeros([l, idx])&lt;=k的最大的idx，可以二分答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int K, N, a[300010], presum[300010];// NlogNint main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); presum[0] = 0; for (int i=0; i&lt;N; i++) &#123; scanf(\"%d\", &amp;a[i]); presum[i+1] = a[i] + presum[i]; &#125; int ans = -1, ans_l; for (int L = 0; L &lt; N; ++L) &#123; int r = N, l = L; while(l &lt; r) &#123; int m = l + (r - l) / 2; // 判断0的个数&lt;=K if (m - L + 1 - (presum[m+1] - presum[L]) &lt;= K) l = m + 1; // 主要看+1在哪 l-1满足条件, r不满足 else r = m; &#125; // l/r即第一个不满足条件的, 即0的个数&gt;K, 即[L, r-1] if (r - L &gt; ans) &#123; ans = r - L; ans_l = L; &#125; &#125; printf (\"%d\\n\", ans); for (int i=0;i&lt;N;i++) &#123; if (i &gt;= ans_l &amp;&amp; i &lt; ans + ans_l) printf (\"%d\", 1); else printf (\"%d\", a[i]); printf (\"%c\", i==N-1?'\\n':' '); &#125; return 0;&#125; 方法2滑动窗口[l, r)，枚举l, r根据l的右移一定要右移，r是l经过K个0后延伸到最右的边界+1，注意r一直在增加，且最大值为N，因此时间复杂度为O(n)，记录滑动窗口的最大宽度(r - l)即可。 12345678910111213141516171819202122232425262728293031323334int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); for (int i=0; i&lt;N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; int zeros = 0; pair&lt;int, int&gt; ans = make_pair(0, 0); for (int l = 0, r = 0; l &lt; N; ++l) &#123; // 循环后，r指向加上即&gt;K的位置 while(r &lt; N &amp;&amp; (zeros + (a[r] == 0)) &lt;= K) &#123; zeros += (a[r] == 0); r++; &#125; ans = max(ans, make_pair(r-l, l)); zeros -= a[l] == 0; &#125; printf (\"%d\\n\", ans.first); for (int i=0;i&lt;N;i++) &#123; // printf (\"i=%d \", i); if (i &gt;= ans.second &amp;&amp; i &lt; ans.first + ans.second) printf (\"%d\", 1); else printf (\"%d\", a[i]); printf (\"%c\", i==N-1?'\\n':' '); &#125; // printf (\"%d %d\", ans.second, ans.first+ans.second-1); return 0;&#125; Notes: 注意pair的使用。 POJ 3111 K Best平均值最大化 51nod1105 第K大的数第K大的数 注意判断大于x的数的个数时，可以再次使用二分直接找到分界点。","tags":[]},{"title":"Hello World","date":"2018-09-15T14:48:12.139Z","path":"2018/09/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]