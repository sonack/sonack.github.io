[{"title":"动态规划专题","date":"2018-11-26T09:14:15.000Z","path":"2018/11/26/动态规划专题/","text":"动态规划(Dynamic Programming, DP)。 DP总结动态规划分类 基础 简单递推 LCS (最长公共子序列/串) LIS (最长上升子序列/串) 背包问题 (0-1\\多重\\完全\\分组) 区间DP 树形DP 数位DP 期望DP 状压DP(插头DP等) 特性 最优子结构 问题的最优解包含子问题的最优解 重叠子问题 f(x) 被重复调用计算 记忆化搜索 无后效性 例题s简单递推HDU 2084. 数塔状态定义：dp[i][j]: 从(0,0)走到(i,j)的最大路径和 状态转移方程： dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + num[i][j] (j &gt;= 1)dp[i][j] = dp[i - 1][j] + num[i][j] (j == 0) 12345678910111213141516171819202122232425262728293031323334// HDU 2084#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int T, N;int a[101][101];int dp[101][101];int main()&#123; // freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; dp[0][0] = a[0][0]; for (int l = 1; l &lt; N; ++l) &#123; dp[l][0] = dp[l - 1][0] + a[l][0]; for (int e = 1; e &lt; l + 1; ++e) &#123; dp[l][e] = max(dp[l - 1][e], dp[l - 1][e - 1]) + a[l][e]; &#125; &#125; int ans = dp[N - 1][0]; for (int i = 1; i &lt; N; ++ i) &#123; ans = max(ans, dp[N - 1][i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[]},{"title":"第K大的数 (二分答案, 笛卡尔乘积第K大)","date":"2018-11-23T11:22:53.000Z","path":"2018/11/23/第K大的数-二分答案-笛卡尔乘积第K大/","text":"数组A和数组B，里面都有n个整数。数组C共有n^2个整数，分别是A[0] B[0],A[0] B[1] … A[1] B[0], A[1] B[1] … A[n - 1] * B[n - 1]（数组A同数组B的组合）。求数组C中第K大的数。例如：A：1 2 3，B：2 3 4。A与B组合成的C包括2 3 4 4 6 8 6 9 12共9个数。 对A和B排序，再二分答案，利用单调性，可以在O(n)内求出有多少个数比当前答案大。 第K大的数，即有K-1个数比它大，定义函数judge(x)判断有多少个数比x大，第一个不满足judge(x)&gt;=K的x，即是第K大的数。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int maxn = 5e4;int n, K;LL a[maxn+10], b[maxn+10];int judge(LL x)&#123; int cnt = 0; for (int i = 0, j = n - 1; i &lt; n; i++) &#123; for (; j &gt;= 0 &amp;&amp; a[i] * b[j] &gt; x; j--); cnt += n - 1 - j; &#125; return cnt;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;K); for(int i = 0; i &lt; n; i++) scanf(\"%lld%lld\", &amp;a[i], &amp;b[i]); sort(a, a+n); sort(b, b+n); LL l = 0, r = 1e18; while (l &lt; r) &#123; LL m = l + (r - l) / 2; if (judge(m) &gt;= K) l = m + 1; else r = m; &#125; printf(\"%lld\", l); return 0;&#125; submit: [https://www.51nod.com/Challenge/Problem.html#!#problemId=1105]","tags":[]},{"title":"POJ 3111 K Best (二分答案, 平均值最大化)","date":"2018-11-23T11:06:25.000Z","path":"2018/11/23/POJ-3111-K-Best-二分答案-平均值最大化/","text":"POJ 3111 题意： n件珠宝，每件价值v_i, 重w_i, 希望保留K件，使得单位重量的价值最大。 直接按照价值重量密度贪心不可，因为各件珠宝的密度所占的比重不同（重量大的，密度也占的比重大），可以二分答案，判断是否存在某种划分，使得单位重量价值&gt;=x，即Σ(vi-wi*x)&gt;=0, 贪心选择前K大的即可判断。二分答案，浮点数二分，求得最大的x，满足单位重量&gt;=x。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, K;struct jewels&#123; int id; int v; int w; double comp_key;&#125;J[100010];bool cmp(const jewels &amp;l, const jewels &amp;r)&#123; return l.comp_key &gt; r.comp_key;&#125;int judge(double x)&#123; for (int i = 0; i &lt; N; i++) J[i].comp_key = J[i].v - J[i].w * x; double sum = 0; sort(J, J + N, cmp); for (int i = 0; i &lt; K; i++) sum += J[i].comp_key; return sum &gt;= 0;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d%d\", &amp;J[i].v, &amp;J[i].w); J[i].id = i+1; &#125; double l = 0, r = 1e8; // (r-l)/2^100的精度足够 可行范围[l,r) for (int i = 0; i &lt; 100; i++) &#123; double mid = (l + r) / 2; if (judge(mid)) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; // printf (\"%.2f\\n\", l); for (int i = 0; i &lt; K; i++) printf (\"%d%c\", J[i].id, i &lt; K - 1 ? ' ' : '\\n'); return 0;&#125;","tags":[]},{"title":"贪心法总结","date":"2018-11-23T08:33:55.000Z","path":"2018/11/23/贪心法总结/","text":"贪心法总结 基本思想在多阶段决策问题中，总是“短视”地做出当前环境下最好的决策（局部最优选择），希望最终整体结果也较优，某些特殊的问题经过证明可以得出贪心结果最终也可能是整体最优解。 一个贪心问题需要有以下要素： 贪心选择性质：这是与DP的不同，一系列局部最优的贪心选择，每做一次贪心选择，就将原问题简化为规模更小的子问题，继而再进行贪心选择。如果对于一个具体问题，可以证明每一步所做的贪心选择最终会导向问题的整体最优解，则问题具有贪心选择性质。 最优子结构性质：整个问题的最优解包含子问题的最优解，可以用反证法证明，DP算法也要求此性质。 经典问题活动时间安排问题 若干个区间[s_i,t_i], 选择尽可能多的不交叉重叠的区间，数量最多为多少贪心选择结束时间更早的活动，因为可以给后续活动留下更多空间，至少不会比最优解差。 submit: [http://www.51nod.com/Challenge/Problem.html#!#problemId=1428] 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N;struct act&#123; int begin, end;&#125;t[10010];bool cmp(act &amp;l, act &amp;r)&#123; return (l.end &lt; r.end) || (l.end == r.end &amp;&amp; l.begin &lt; r.begin);&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); for (int i=0;i&lt;N;i++) scanf(\"%d%d\", &amp;t[i].begin, &amp;t[i].end); sort(t, t+N, cmp); int last_time = -1, ans = 0; for (int i=0;i&lt;N;i++) &#123; if (t[i].begin &gt;= last_time) &#123; ans++; last_time = t[i].end; &#125; &#125; printf (\"%d\\n\", ans); return 0;&#125; 区间覆盖问题POJ 3069 直线上有N个点，{ Xi | i=1…N }，选择若干个加上标记，每个标记可以覆盖距离为R的区域，希望为尽可能少的点添加标记，问至少要标记多少个点？ 从最左边的点开始考虑，保证能覆盖它，且尽可能右移的点被标记，再找到第一个没被覆盖的点，用同样的贪心策略求解。 NYOJ 1170 最大的数 n个数，在n-1个间隔中间添加+号或者*号，可以任意添加括号，但不许改变相对顺序，使结果最大。 不难发现，如果没有1，乘法一定比加法大。如果有1，则应该选择将1加在左边还是加在右边，a 1 b, (a+1)b与a\\(1+b)相比，发现应该把1加在较小的一侧。但是当a==b时，如何选择？由 4 1 4 1 的最优方案是 (4+1)*(4+1)，应该优先加在左边。当a值比较小时，该规律并不适用，比如 2 1 1 2的最优方案时(2+1)*(1+2)=9，而不是(2 (1 + 1) 2)=8，因此特殊情况需要判断，即 2 1 1 时，应该把中间的1加在左边的2，而不是右边较小的1，且(2+1)+1=4=2*(1+1)，每次把1加上后，原来的1相当于消失，最后累乘所有元素即是最大的结果。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MOD 10086 using namespace std;int N, a[10005];int main()&#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d\", &amp;N)) &#123; a[0] = a[N+1] = 21; for (int i = 1; i &lt;= N; i++) scanf(\"%d\", &amp;a[i]); if (N &gt; 1) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (a[i] == 1) &#123; // 1 加在左边 if(a[i-1] &lt;= a[i+1] || (a[i-1] == 2 &amp;&amp; a[i+1] == 1)) &#123; a[i] += a[i-1]; a[i-1] = 1; &#125; // 1 加在右边 else &#123; a[i+1] += a[i]; i++; &#125; &#125; &#125; &#125; for (int i = 2; i &lt;= N; i++) a[1] = (a[1] * a[i]) % MOD; printf(\"%d\\n\", a[1]); &#125; return 0;&#125; 合并果子 现在有n堆果子，第i堆有ai个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 类似于哈夫曼编码，贪心合并最少的两堆果子，可以用优先队列或堆进行优化，时间复杂度为O(nlogn). 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 洛谷 P1090 https://www.luogu.org/problemnew/show/P1090#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;// #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAXN = 1e5;int fruits[MAXN + 10];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int T, N, tmp1, tmp2; // cin &gt;&gt; T; T = 1; while(T--) &#123; LL ans = 0; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; fruits[i]; Q.push(fruits[i]); &#125; sort(fruits, fruits + N); for (int i = 0; i &lt; N - 1; ++i) &#123; tmp1 = Q.top(); Q.pop(); tmp2 = Q.top(); Q.pop(); ans += (tmp1 + tmp2); Q.push(tmp1 + tmp2); &#125; // for (int i = 0; i &lt; N - 1; ++i) &#123; // LL tmp = (fruits[i + 1] += fruits[i]); // ans += tmp; // int j; // for (j = i + 2; j &lt; N &amp;&amp; fruits[j] &lt; tmp; ++j) &#123; // fruits[j - 1] = fruits[j]; // &#125; // fruits[j - 1] = tmp; // &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[]},{"title":"二分法总结","date":"2018-11-22T07:43:49.000Z","path":"2018/11/22/二分法总结/","text":"二分法总结 二分查找有序数组a(a[0], … a[N-1]), 查找目标值target，维护一个target所在区间[l, r), 每次与中间元素a[m]比较(m=floor((l + r) / 2))，确定target所在区间，且区间长度缩减一半，依次进行，最终在长度为N的数组a中查找target值总共需要O(logN)时间复杂度，空间复杂度为O(1). C++ STL APIs Usage12345678910111213141516171819202122// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vector// lower_bound 第一个i, a[i] &gt;= t// upper_bound 第一个i, a[i] &gt; t// [lower_bound, upper_bound) int main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); up=std::upper_bound (v.begin(), v.end(), 20); std::cout &lt;&lt; \"lower_bound at position \" &lt;&lt; (low- v.begin()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper_bound at position \" &lt;&lt; (up - v.begin()) &lt;&lt; '\\n'; return 0;&#125; C++ STL APIs python implementationsref: [https://www.zhihu.com/question/3613238] C++ STL lower_bound() python implementation: 1234567891011# ie. find the smallest i such that a[i] &gt;= valuedef lower_bound(array, first, last, value): while (first &lt; last): # mid = first + ((last - first) &gt;&gt; 1) 注意&gt;&gt;优先级最低，需要加括号 # 不用(first + last) // 2 防止溢出 mid = first + (last - first) // 2 if (array[mid] &lt; value): first = mid + 1 else: last = mid return first C++ STL upper_bound() python implementation: 12345678910# ie. find the smallest i such that a[i] &gt; valuedef upper_bound(array, first, last, value): while (first &lt; last): mid = first + (last - first) // 2 # 此处看做条件c if (array[mid] &lt;= value): first = mid + 1 else: last = mid return first C++ STL APIs C++ implementations12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) // 只有此处不同 l = m + 1; else r = m; &#125; return l;&#125;// [l,r] 区间写法// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; //注意right初始化为n-1 int left(0), right(n-1), mid; while(left &lt;= right) // 注意结束判别条件，l&lt;=r 而不是 l&lt;r &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; // 注意 -1 &#125; &#125; return left; // left和right不一致，注意要返回left&#125;// return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right) &#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 总结： 无论是lower_bound()还是upper_bound(), 都是返回不满足条件c的最小下标； return first or last是等价的; 区间表示法为[first, last)。 二分答案如果一个问题的解是离散的，且范围已知（ie 可以枚举），且判断一个解是否可行的代价较低，且答案具有单调性(ie 如果x是解，则x+i也是解， 如果x不是解，则x-i也不是解（或者反过来）。即满足条件和不满足条件的交界面只有一个，类似于判断条件C，array[i]&lt;value的条件在有序数组内即满足单调性)，则可以采用二分答案的做法来求解。 例题s二分搜索题目列表Ref: [https://blog.csdn.net/linhuanmars/article/details/31354941] Leetcode 35. Search Insert Position123456789101112131415161718192021222324252627282930313233343536373839404142434445// method 1int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; const int n = nums.size(); int l=0, r=n-1; while(l&lt;=r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] == target) return mid; if (nums[mid] &lt; target) l = mid+1; else r = mid-1; &#125; return l;&#125;// method 2 lower_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt; target) l = m + 1; else r = m; &#125; return l;&#125;// method 3 upper_boundint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size(); // the 1st to not obby nums[i] &lt; target, ie nums[i] &gt; target while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt;= target) l = m + 1; else r = m; &#125; // 如果找到了则返回下标l-1, 没找到的话插入位置则是l if (l &amp;&amp; nums[l-1] == target) l--; return l;&#125; Leetcode ?. Search for a Range123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int lower_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt; T) l = m + 1; else r = m; &#125; return l;&#125;int upper_bound(int *A, int N, int T)&#123; int l=0, r=N; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (A[m] &lt;= T) l = m + 1; else r = m; &#125; return l;&#125;// return the first element which &gt;= xint LowerBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt; x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; printf (\"l=%d, r=%d\",left, right); return left;&#125; // return first element which &gt; xint UpperBound(int *a, int n, int x)&#123; int left(0), right(n-1), mid; while(left &lt;= right)&#123; mid = left + ((right - left) &gt;&gt; 1); if(a[mid] &lt;= x)&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; return left;&#125;int main()&#123; freopen(\"input.txt\", \"r\", stdin); int a[100],N,T; scanf(\"%d%d\", &amp;N, &amp;T); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; sort(a,a+N); // int lb = lower_bound(a, N, T); // int ub = upper_bound(a, N, T); int lb = LowerBound(a, N, T); int ub = UpperBound(a, N, T); printf(\"%d-%d\\n\", lb, ub); return 0;&#125; Leetcode 69. Sqrt(x)123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // 如果采用[l,r)写法，则r可能会溢出有符号整数的范围 // 采用[l,r]写法 // 找到第一个满足m&gt;x/m的m，ie m**2&gt;x的值， // 则m-1就是平方&lt;=x的最大整数，即sqrt(x)的整数部分。 int mySqrt(int x) &#123; int l = 1, r = x; while(l&lt;=r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m - 1; &#125; return l-1; &#125; // [l,r)写法，采用了unsigned int防止溢出 int mySqrt(int x) &#123; unsigned int l = 1, r = x+1; while(l&lt;r) &#123; int m = l + (r - l) / 2; if (m&lt;=x/m) l = m + 1; else r = m; &#125; return l-1; &#125;&#125;; Notes: 注意m&lt;=x/m的写法，替代了m*m&lt;=x的写法，防止溢出。 Leetcode 74. Search a 2D Matrix首先找到第一个元素matrix[i][0]&lt;=target的行i，再在matrix[i]内二分查找target值。时间复杂度为O(logn+logn), ie O(logn). 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int l = 0, r = matrix.size(); // 一旦有空行，则返回false // [] if (r == 0) return false; // [[]] if(matrix[0].size() == 0) return false; // [l,r), 查找第一个首元素&gt;target的行 while (l &lt; r) &#123; int m = l + (r - l) / 2; if (matrix[m][0] &lt;= target) l = m + 1; else r = m; &#125; // select 即为最后一个 &lt;= target的行 int select = l - 1; // 第一行的首元素都＞target，肯定不存在 if (select &lt; 0) &#123; return false; &#125; // [l,r] l = 0, r = matrix[select].size()-1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (matrix[select][m] &lt; target) l = m + 1; else if (matrix[select][m] &gt; target) r = m - 1; else return true; &#125; return false; &#125;&#125;; Leetcode 33. Search in Rotated Sorted Array因为没有重复元素，所以原始数组一定严格单调递增。可以根据a[m]与a[r]的大小关系，判断单调部分是[l,m]还是[m,r]（两者必然存在一个单调，因为断点只有一个，根据鸽巢定理)，再根据情况进行二分即可。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size()-1; // [l,r] while (l&lt;=r) &#123; int m = (l + r) / 2; // 直接找到 if (nums[m] == target) return m; // [m,r]一定单调 if (nums[m] &lt; nums[r]) &#123; // 判断是否在右侧 if (nums[m] &lt; target &amp;&amp; nums[r] &gt;= target) l = m+1; else r = m-1; &#125; // nums[m] &gt; nums[r], 断点在右侧，左侧[l,m]一定单调 else &#123; // 判断target是否在左侧 if (nums[l] &lt;= target &amp;&amp; nums[m] &gt; target) r = m-1; else // 否则在右侧 l = m+1; &#125; &#125; return -1; &#125;&#125;; Leetcode 81. Search in Rotated Sorted Array II有重复元素，可能只是非递减序列，无法再根据a[m]和a[r]的大小关系判断非递减部分，eg [2 2 2 2 2 3] rotate to [2 3 | 2 2 2 2] (a[m]=2=a[r],断点在左侧，右侧非递减) 或者 rotate to [2 2 2 2 3 | 2] (a[m]=2=a[r], 断点在右侧，左侧非递减)，但是当a[m]&lt;a[r]时，还是可以判断出来断点一定在左边的，因为在右边的话，只能有a[m]&gt;=a[r]，同理当a[m]&gt;a[r]时，单调区间为[l,m].如果a[m]与a[r]相等，则r–，因为无法判断，且a[r]!=target(a[m]!=target已经判断过了)肯定不是答案，缩减问题规模1个单位，最坏时间复杂度为O(n). 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int m = l + (r - l) / 2; if (nums[m] == target) return true; if (nums[m] &lt; nums[r]) &#123; if (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + 1; else r = m - 1; &#125; else if (nums[m] &gt; nums[r]) &#123; if (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - 1; else l = m + 1; &#125; else &#123; r--; &#125; &#125; return false; &#125; 洛谷 P1024 一元三次方程求解已知根与根之间距离&gt;=1，因此只要用长度为1的区间去二分求解即可，注意区间端点重叠可能会重复答案，因此在挪动区间时需要加一个小eps防止答案在端点处被求解两次。也可以根据答案求解情况挪动区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;double eps = 1e-4;double interval_width = 1;double A,B,C,D;double f(double x)&#123; return A*x*x*x+B*x*x+C*x+D;&#125;double get_ans(double l, double r)&#123; // printf(\"(l=%lf, r=%lf)\", l,r); if (f(l) * f(r) &gt; 0) return 9999; while(r-l&gt;eps) &#123; double m = (l+r) / 2; if (f(m) * f(l) &lt;=0) r = m; else l = m; &#125; return (l+r)/2;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); vector&lt;double&gt; ans; double l = -100; scanf(\"%lf%lf%lf%lf\", &amp;A, &amp;B, &amp;C, &amp;D); while(l&lt;100) &#123; double solu = get_ans(l, l+interval_width); if (solu &lt; 101) &#123; ans.push_back(solu); // printf(\"%.2lf\", solu); &#125; l+=interval_width+eps; &#125; sort(ans.begin(), ans.end()); for (int i=0;i&lt;ans.size();i++) printf(\"%.2f \", ans[i]); return 0;&#125; 二分答案POJ 3258 跳石头 River Hopscotch最短跳跃距离最大–最小值最大问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int L, m, n;int a[50010];// 判断最短距离不少于x是否可以达到int check(int x)&#123; int last = 0; int moves = 0; for (int i=0;i&lt;=n;i++) &#123; if (a[i+1] - last &lt; x) // 太近了，需要搬石头 &#123; moves++; &#125; else &#123; last = a[i+1]; &#125; &#125; if (moves &gt; m) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d%d\", &amp;L, &amp;n, &amp;m); a[0] = 0; for (int i=1; i&lt;=n; i++) scanf(\"%d\", &amp;a[i]); a[n+1] = L; sort(a, a+n+2); int l = 0, r = L + 1; // 第一个不满足check(m)的m值，即第一个不能达到最短距离&gt;=m的m，即第一个无法使所有最短距离都&gt;=m的m,则m-1就是最大的最小值 while (l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); // printf (\"%d,%d,%d\\n\", l, r, m); // 最短距离&gt;=m可以达到 if (check(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf (\"%d\", l - 1); return 0;&#125; 洛谷 P1182 数列分段42451 [42][45][1]每段和最大值最小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, M;int a[100010]; // 判断每段和都&lt;=x, 即最大值&lt;=x是否可行int judge(int x)&#123; int i=0; int cur_sum = 0; int part_cnt = 0; while(i&lt;N) &#123; if (a[i] &gt; x) return 0; cur_sum += a[i++]; if (cur_sum &gt; x) &#123; i--; cur_sum = 0; part_cnt++; &#125; &#125; if (cur_sum) part_cnt++; if (part_cnt &gt; M) return 0; return 1;&#125;int main()&#123; // freopen(\"input.txt\",\"r\",stdin); scanf(\"%d%d\", &amp;N, &amp;M); int l = -1, r = 0; for (int i=0;i&lt;N;i++) &#123; scanf(\"%d\", &amp;a[i]); r += a[i]; l = max(l, a[i]); &#125; r++; // 满足judge(m)的最小的m while(l &lt; r) &#123; int m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; r = m; &#125; else &#123; l = m+1; &#125; &#125; printf (\"%d\", l); return 0;&#125; 洛谷 P1577 切绳子1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, K;int a[10010];int judge(int m)&#123; int cnt = 0; for (int i=0; i&lt;N; i++) &#123; cnt += a[i] / m; &#125; if (cnt &gt;= K) return 1; return 0;&#125;int main()&#123; // freopen(\"input.txt\", \"r\", stdin); int l=0, r=-1; double inp; scanf(\"%d%d\",&amp;N,&amp;K); for (int i=0;i&lt;N;i++) &#123; scanf(\"%lf\",&amp;inp); a[i] = int(inp * 100000); r = max(r, a[i]); &#125; while(l&lt;r) &#123; double m = l + ((r - l) &gt;&gt; 1); if (judge(m)) &#123; l = m + 1; &#125; else &#123; r = m; &#125; &#125; printf(\"%.2lf\", (l-1)/100000.0); return 0;&#125; CodeForces 660C. Hard Process 给定n个01元素的数组，每次操作可以将一个0变为1，求最多经过K次操作最长的连续的1的个数。 最简单的方法0O(n^2)枚举区间的左右端点[l, r], 如果其中0的个数&lt;=K, 则可以经过不超过K次将其全变为1，ans = max(ans, r - l + 1).判断0的个数，可以用前缀和O(1)时间完成。方法1O(nlogn)只枚举左端点l，右端点r即满足Zeros([l, idx])&lt;=k的最大的idx，可以二分答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int K, N, a[300010], presum[300010];// NlogNint main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); presum[0] = 0; for (int i=0; i&lt;N; i++) &#123; scanf(\"%d\", &amp;a[i]); presum[i+1] = a[i] + presum[i]; &#125; int ans = -1, ans_l; for (int L = 0; L &lt; N; ++L) &#123; int r = N, l = L; while(l &lt; r) &#123; int m = l + (r - l) / 2; // 判断0的个数&lt;=K if (m - L + 1 - (presum[m+1] - presum[L]) &lt;= K) l = m + 1; // 主要看+1在哪 l-1满足条件, r不满足 else r = m; &#125; // l/r即第一个不满足条件的, 即0的个数&gt;K, 即[L, r-1] if (r - L &gt; ans) &#123; ans = r - L; ans_l = L; &#125; &#125; printf (\"%d\\n\", ans); for (int i=0;i&lt;N;i++) &#123; if (i &gt;= ans_l &amp;&amp; i &lt; ans + ans_l) printf (\"%d\", 1); else printf (\"%d\", a[i]); printf (\"%c\", i==N-1?'\\n':' '); &#125; return 0;&#125; 方法2滑动窗口[l, r)，枚举l, r根据l的右移一定要右移，r是l经过K个0后延伸到最右的边界+1，注意r一直在增加，且最大值为N，因此时间复杂度为O(n)，记录滑动窗口的最大宽度(r - l)即可。 12345678910111213141516171819202122232425262728293031323334int main()&#123; // freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); for (int i=0; i&lt;N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; int zeros = 0; pair&lt;int, int&gt; ans = make_pair(0, 0); for (int l = 0, r = 0; l &lt; N; ++l) &#123; // 循环后，r指向加上即&gt;K的位置 while(r &lt; N &amp;&amp; (zeros + (a[r] == 0)) &lt;= K) &#123; zeros += (a[r] == 0); r++; &#125; ans = max(ans, make_pair(r-l, l)); zeros -= a[l] == 0; &#125; printf (\"%d\\n\", ans.first); for (int i=0;i&lt;N;i++) &#123; // printf (\"i=%d \", i); if (i &gt;= ans.second &amp;&amp; i &lt; ans.first + ans.second) printf (\"%d\", 1); else printf (\"%d\", a[i]); printf (\"%c\", i==N-1?'\\n':' '); &#125; // printf (\"%d %d\", ans.second, ans.first+ans.second-1); return 0;&#125; Notes: 注意pair的使用。 POJ 3111 K Best平均值最大化 51nod1105 第K大的数第K大的数 注意判断大于x的数的个数时，可以再次使用二分直接找到分界点。","tags":[]},{"title":"Hello World","date":"2018-09-15T14:48:12.139Z","path":"2018/09/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]